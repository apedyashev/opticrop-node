// Generated by CoffeeScript 1.7.1
var GAMMA, Opticrop, async, getPixels, gm, utils;

gm = require('gm');

async = require('async');

getPixels = require("get-pixels");

utils = require("./utils.js");

GAMMA = 0.2;

Opticrop = (function() {
  function Opticrop() {}

  Opticrop.prototype.setImage = function(inImage) {
    this._image = inImage;
    return this;
  };

  Opticrop.prototype.setWidth = function(inWidth) {
    this._width = inWidth;
    return this;
  };

  Opticrop.prototype.setHeight = function(inHeight) {
    this._height = inHeight;
    return this;
  };

  Opticrop.prototype.cropTo = function(outImage, done) {
    if (this._image == null) {
      return done('Image to me cropped is not set. Please use the setImage() function');
    }
    if (this._width == null) {
      return done('Cropped image width is not set. Please use the setWidth() function');
    }
    if (this._height == null) {
      return done('Cropped image height is not set. Please use the setWidth() function');
    }
    return this._crop(this._image, this._width, this._height, outImage, done);
  };

  Opticrop.prototype._crop = function(inImage, inWidth, inHeight, outImage, done) {
    var gmImage, gmInImage;
    gmImage = gm(inImage);
    gmInImage = gm(inImage);
    return async.auto({
      size: function(cb) {
        return gmImage.size(function(err, val) {
          return cb(err, val);
        });
      },
      createEdgedImage: [
        'size', (function(_this) {
          return function(cb, results) {
            var edgeFilterRadius;
            if ((inWidth > results.size.width) || (inHeight > results.size.height)) {
              return cb("Target dimensions must be smaller or equal to source dimensions.");
            }
            edgeFilterRadius = 1;
            return gmImage.edge(edgeFilterRadius).modulate(100, 0, 100).blackThreshold(15, 15, 15).write(outImage, function(err) {
              return cb(err, {
                resultFile: outImage
              });
            });
          };
        })(this)
      ],
      calculateCenter: [
        'size', 'createEdgedImage', (function(_this) {
          return function(cb, results) {
            return getPixels(results.createEdgedImage.resultFile, function(err, pixels) {
              var area, beta, betanorm, c, h0, hcrop, hcrop0, hgap, hinc, i, j, k, maxbetanorm, maxparam, n, nk, sum, targetAspectRatio, val, w0, wcrop, wcrop0, wgap, winc, xcenter, xcrop, ycenter, ycrop, _i, _j, _k, _ref, _ref1;
              if (err) {
                console.log("Bad image path");
                return cb("Bad image path");
              }
              xcenter = 0;
              ycenter = 0;
              sum = 0;
              n = 100000;
              for (k = _i = 0; 0 <= n ? _i < n : _i > n; k = 0 <= n ? ++_i : --_i) {
                i = utils.random(0, results.size.width - 1);
                j = utils.random(0, results.size.height - 1);
                val = pixels.get(j, i, 2);
                sum += val;
                xcenter += (i + 1) * val;
                ycenter += (j + 1) * val;
              }
              xcenter /= sum;
              ycenter /= sum;
              targetAspectRatio = inWidth / inHeight;
              if (results.size.width / results.size.height > targetAspectRatio) {
                wcrop0 = Math.round(targetAspectRatio * results.size.height);
                hcrop0 = results.size.height;
              } else {
                wcrop0 = results.size.width;
                hcrop0 = Math.round(results.size.width / targetAspectRatio);
              }
              nk = 9;
              hgap = hcrop0 - inHeight;
              hinc = (_ref = nk === 1) != null ? _ref : {
                0: hgap / (nk - 1)
              };
              wgap = wcrop0 - inWidth;
              winc = (_ref1 = nk === 1) != null ? _ref1 : {
                0: wgap / (nk - 1)
              };
              n = 10000;
              maxbetanorm = 0;
              maxparam = {
                'w': 0,
                'h': 0,
                'x': 0,
                'y': 0
              };
              w0 = results.size.width;
              h0 = results.size.height;
              for (k = _j = 0; 0 <= nk ? _j < nk : _j > nk; k = 0 <= nk ? ++_j : --_j) {
                hcrop = Math.round(hcrop0 - k * hinc);
                wcrop = Math.round(wcrop0 - k * winc);
                xcrop = xcenter - wcrop / 2;
                ycrop = ycenter - hcrop / 2;
                if (xcrop < 0) {
                  xcrop = 0;
                }
                if (xcrop + wcrop > w0) {
                  xcrop = w0 - wcrop;
                }
                if (ycrop < 0) {
                  ycrop = 0;
                }
                if (ycrop + hcrop > h0) {
                  ycrop = h0 - hcrop;
                }
                beta = 0;
                for (c = _k = 0; 0 <= n ? _k < n : _k > n; c = 0 <= n ? ++_k : --_k) {
                  i = utils.random(0, wcrop - 1);
                  j = utils.random(0, hcrop - 1);
                  beta += pixels.get(ycrop + j, xcrop + i, 2);
                }
                area = wcrop * hcrop;
                betanorm = beta / (n * Math.pow(area, GAMMA - 1));
                if (betanorm > maxbetanorm) {
                  maxbetanorm = betanorm;
                  maxparam['w'] = wcrop;
                  maxparam['h'] = hcrop;
                  maxparam['x'] = xcrop;
                  maxparam['y'] = ycrop;
                }
              }
              return cb(null, {
                width: maxparam['w'],
                height: maxparam['h'],
                x: maxparam['x'],
                y: maxparam['y']
              });
            });
          };
        })(this)
      ],
      cropImage: [
        'calculateCenter', (function(_this) {
          return function(cb, result) {
            gmInImage.crop(result.calculateCenter.width, result.calculateCenter.height, result.calculateCenter.x, result.calculateCenter.y);
            return cb(null);
          };
        })(this)
      ],
      scaleImage: [
        'calculateCenter', 'cropImage', (function(_this) {
          return function(cb, result) {
            gmInImage.scale(inWidth, inHeight);
            return cb(null);
          };
        })(this)
      ]
    }, (function(_this) {
      return function(err, results) {
        if (err) {
          return done(err);
        }
        return gmInImage.write(outImage, function(err) {
          return done(err);
        });
      };
    })(this));
  };

  return Opticrop;

})();

module.exports = Opticrop;
